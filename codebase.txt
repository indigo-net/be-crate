This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    update-codebase.yml
prisma/
  migrations/
    20251221104021_init_user/
      migration.sql
    20251223063804_init_user/
      migration.sql
    20251223163713_add_form/
      migration.sql
    20251223184350_add_question/
      migration.sql
    20251224164952_add_question_option/
      migration.sql
    20251228100240/
      migration.sql
    20251228114027_add_refresh_token/
      migration.sql
    20260102102758_add_form_status/
      migration.sql
    migration_lock.toml
  schema.prisma
src/
  auth/
    dto/
      kakao-login.dto.ts
      login.dto.ts
      signup.dto.ts
    guards/
      jwt-auth.guard.ts
      optional-jwt-auth.guard.ts
    strategies/
      jwt.strategy.ts
    auth.controller.ts
    auth.module.ts
    auth.service.ts
    refresh-token.service.ts
  common/
    prisma/
      prisma.module.ts
      prisma.service.ts
  forms/
    dto/
      draft/
        create-form-draft.dto.ts
        create-form-publish.dto.ts
      create-form.dto.ts
      update-form.dto.ts
    forms.controller.ts
    forms.module.ts
    forms.service.ts
  permissions/
    permissions.module.ts
    permissions.service.ts
  public-links/
    public-links.controller.ts
    public-links.module.ts
  question-options/
    dto/
      create-question-option.dto.ts
      delete-question-option.dto.ts
      reorder-question-option.dto.ts
    question-options.controller.ts
    question-options.module.ts
    question-options.service.ts
  questions/
    dto/
      create-question.dto.ts
      reorder-questions.dto.ts
      update-question.dto.ts
    questions.controller.ts
    questions.module.ts
    questions.service.ts
  responses/
    dto/
      create-response-answer.dto.ts
      create-response.dto.ts
    responses.controller.ts
    responses.module.ts
    responses.service.ts
  users/
    users.controller.ts
    users.module.ts
    users.service.ts
  app.module.ts
  main.ts
test/
  app.e2e-spec.ts
  jest-e2e.json
.env.dev
.env.prod
.eslintrc.js
.gitignore
.prettierrc
docker-compose.yml
nest-cli.json
package.json
README.md
tsconfig.build.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/update-codebase.yml">
name: Update Codebase

on:
  pull_request:
    types: [closed]

jobs:
  update-codebase:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: ÏΩîÎìú Ï≤¥ÌÅ¨ÏïÑÏõÉ
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}

      - name: Node.js ÌôòÍ≤Ω ÏÑ§Ï†ï
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: ÏΩîÎìúÎ≤†Ïù¥Ïä§ Î∂ÑÏÑù Î∞è codebase.txt ÏÉùÏÑ±
        run: npx -y repomix --output codebase.txt --style xml

      - name: Î≥ÄÍ≤Ω ÏÇ¨Ìï≠ Ïª§Î∞ã Î∞è Ìë∏Ïãú
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add codebase.txt
          git commit -m "chore: update codebase.txt [skip ci]" || echo "No changes to commit"
          git push
</file>

<file path="prisma/migrations/20251221104021_init_user/migration.sql">
-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
</file>

<file path="prisma/migrations/20251223063804_init_user/migration.sql">
/*
  Warnings:

  - You are about to drop the column `createdAt` on the `User` table. All the data in the column will be lost.
  - Added the required column `password_hash` to the `User` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "User" DROP COLUMN "createdAt",
ADD COLUMN     "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "name" TEXT,
ADD COLUMN     "password_hash" TEXT NOT NULL;
</file>

<file path="prisma/migrations/20251223163713_add_form/migration.sql">
-- CreateTable
CREATE TABLE "Form" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "owner_id" TEXT NOT NULL,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Form_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "Form_owner_id_idx" ON "Form"("owner_id");

-- AddForeignKey
ALTER TABLE "Form" ADD CONSTRAINT "Form_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20251223184350_add_question/migration.sql">
-- CreateEnum
CREATE TYPE "QuestionType" AS ENUM ('SHORT_TEXT', 'LONG_TEXT', 'SINGLE_CHOICE', 'MULTIPLE_CHOICE');

-- CreateTable
CREATE TABLE "Question" (
    "id" TEXT NOT NULL,
    "form_id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "type" "QuestionType" NOT NULL,
    "is_required" BOOLEAN NOT NULL DEFAULT false,
    "order_index" INTEGER NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Question_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "Question_form_id_idx" ON "Question"("form_id");

-- CreateIndex
CREATE UNIQUE INDEX "Question_form_id_order_index_key" ON "Question"("form_id", "order_index");

-- AddForeignKey
ALTER TABLE "Question" ADD CONSTRAINT "Question_form_id_fkey" FOREIGN KEY ("form_id") REFERENCES "Form"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20251224164952_add_question_option/migration.sql">
-- CreateTable
CREATE TABLE "QuestionOption" (
    "id" TEXT NOT NULL,
    "question_id" TEXT NOT NULL,
    "label" TEXT NOT NULL,
    "value" TEXT,
    "order_index" INTEGER NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "QuestionOption_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "QuestionOption_question_id_idx" ON "QuestionOption"("question_id");

-- CreateIndex
CREATE UNIQUE INDEX "QuestionOption_question_id_order_index_key" ON "QuestionOption"("question_id", "order_index");

-- AddForeignKey
ALTER TABLE "QuestionOption" ADD CONSTRAINT "QuestionOption_question_id_fkey" FOREIGN KEY ("question_id") REFERENCES "Question"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20251228100240/migration.sql">
/*
  Warnings:

  - You are about to drop the column `created_at` on the `User` table. All the data in the column will be lost.
  - You are about to drop the column `password_hash` on the `User` table. All the data in the column will be lost.
  - A unique constraint covering the columns `[provider,providerId]` on the table `User` will be added. If there are existing duplicate values, this will fail.

*/
-- CreateEnum
CREATE TYPE "AuthProvider" AS ENUM ('LOCAL', 'KAKAO', 'GOOGLE');

-- AlterTable
ALTER TABLE "User" DROP COLUMN "created_at",
DROP COLUMN "password_hash",
ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "passwordHash" TEXT,
ADD COLUMN     "provider" "AuthProvider" NOT NULL DEFAULT 'LOCAL',
ADD COLUMN     "providerId" TEXT,
ALTER COLUMN "email" DROP NOT NULL;

-- CreateIndex
CREATE UNIQUE INDEX "User_provider_providerId_key" ON "User"("provider", "providerId");
</file>

<file path="prisma/migrations/20251228114027_add_refresh_token/migration.sql">
-- CreateTable
CREATE TABLE "RefreshToken" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "tokenHash" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "revokedAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "RefreshToken_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "RefreshToken_tokenHash_key" ON "RefreshToken"("tokenHash");

-- CreateIndex
CREATE INDEX "RefreshToken_userId_idx" ON "RefreshToken"("userId");

-- AddForeignKey
ALTER TABLE "RefreshToken" ADD CONSTRAINT "RefreshToken_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20260102102758_add_form_status/migration.sql">
-- CreateEnum
CREATE TYPE "FormStatus" AS ENUM ('DRAFT', 'PUBLISHED');

-- AlterTable
ALTER TABLE "Form" ADD COLUMN     "status" "FormStatus" NOT NULL DEFAULT 'DRAFT';

-- CreateTable
CREATE TABLE "Response" (
    "id" TEXT NOT NULL,
    "form_id" TEXT NOT NULL,
    "responderId" TEXT,
    "publicToken" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Response_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ResponseAnswer" (
    "id" TEXT NOT NULL,
    "response_id" TEXT NOT NULL,
    "question_id" TEXT NOT NULL,
    "option_id" TEXT,
    "value_text" TEXT,

    CONSTRAINT "ResponseAnswer_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "Response_form_id_idx" ON "Response"("form_id");

-- CreateIndex
CREATE INDEX "Response_publicToken_idx" ON "Response"("publicToken");

-- CreateIndex
CREATE INDEX "ResponseAnswer_question_id_idx" ON "ResponseAnswer"("question_id");

-- CreateIndex
CREATE UNIQUE INDEX "ResponseAnswer_response_id_question_id_key" ON "ResponseAnswer"("response_id", "question_id");

-- AddForeignKey
ALTER TABLE "Response" ADD CONSTRAINT "Response_form_id_fkey" FOREIGN KEY ("form_id") REFERENCES "Form"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ResponseAnswer" ADD CONSTRAINT "ResponseAnswer_response_id_fkey" FOREIGN KEY ("response_id") REFERENCES "Response"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ResponseAnswer" ADD CONSTRAINT "ResponseAnswer_question_id_fkey" FOREIGN KEY ("question_id") REFERENCES "Question"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ResponseAnswer" ADD CONSTRAINT "ResponseAnswer_option_id_fkey" FOREIGN KEY ("option_id") REFERENCES "QuestionOption"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//// =====================
//// Auth / User
//// =====================

model User {
  id           String       @id @default(uuid())
  email        String?      @unique
  passwordHash String?
  name         String?
  provider     AuthProvider @default(LOCAL)
  providerId   String?
  createdAt    DateTime     @default(now())

  forms         Form[]
  refreshTokens RefreshToken[]

  @@unique([provider, providerId])
}

enum AuthProvider {
  LOCAL
  KAKAO
  GOOGLE
}

model RefreshToken {
  id        String    @id @default(uuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
}

//// =====================
//// Form / Question
//// =====================

enum FormStatus {
  DRAFT
  PUBLISHED
}

model Form {
  id          String   @id @default(uuid())
  title       String
  description String?
  owner_id    String
  status      FormStatus @default(DRAFT)
  is_active   Boolean  @default(true)   // ÏùºÎã® Ïú†ÏßÄ
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  owner     User       @relation(fields: [owner_id], references: [id])
  questions Question[]
  responses Response[]

  @@index([owner_id])
}

enum QuestionType {
  SHORT_TEXT
  LONG_TEXT
  SINGLE_CHOICE
  MULTIPLE_CHOICE
}

model Question {
  id          String       @id @default(uuid())
  form_id     String
  title       String
  type        QuestionType
  is_required Boolean      @default(false)
  order_index Int
  created_at  DateTime     @default(now())
  updated_at  DateTime     @updatedAt

  form     Form             @relation(fields: [form_id], references: [id])
  options  QuestionOption[]
  answers  ResponseAnswer[]

  @@unique([form_id, order_index])
  @@index([form_id])
}

model QuestionOption {
  id          String   @id @default(uuid())
  question_id String
  label       String
  value       String?
  order_index Int
  created_at  DateTime @default(now())

  question Question @relation(fields: [question_id], references: [id])
  answers  ResponseAnswer[]

  @@unique([question_id, order_index])
  @@index([question_id])
}

model Response {
  id          String   @id @default(uuid())
  form_id     String
  responderId String?
  publicToken String?
  created_at  DateTime @default(now())

  form    Form             @relation(fields: [form_id], references: [id])
  answers ResponseAnswer[]

  @@index([form_id])
  @@index([publicToken])
}

model ResponseAnswer {
  id          String   @id @default(uuid())
  response_id String
  question_id String
  option_id   String?
  value_text  String?

  response Response        @relation(fields: [response_id], references: [id])
  question Question        @relation(fields: [question_id], references: [id])
  option   QuestionOption? @relation(fields: [option_id], references: [id])

  @@unique([response_id, question_id])
  @@index([question_id])
}
</file>

<file path="src/auth/dto/kakao-login.dto.ts">
import { IsString, IsNotEmpty } from 'class-validator';

export class KakaoLoginDto {
    @IsString()
    @IsNotEmpty()
    code: string;
}
</file>

<file path="src/auth/dto/login.dto.ts">
import { IsEmail, IsString } from 'class-validator';

export class LoginDto {
    @IsEmail()
    email: string;

    @IsString()
    password: string;
}
</file>

<file path="src/auth/dto/signup.dto.ts">
import { IsEmail, IsString, IsOptional, MinLength } from 'class-validator';

export class SignupDto {
    @IsEmail()
    email: string;

    @IsString()
    @MinLength(6)
    password: string;

    @IsString()
    @IsOptional()
    name?: string;
}
</file>

<file path="src/auth/guards/jwt-auth.guard.ts">
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') { }
</file>

<file path="src/auth/guards/optional-jwt-auth.guard.ts">
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class OptionalJwtAuthGuard extends AuthGuard('jwt') {
    handleRequest(err: any, user: any) {
        if (err || !user) {
            return null;
        }
        return user;
    }
}
</file>

<file path="src/auth/strategies/jwt.strategy.ts">
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

import { UsersService } from '@/users/users.service';

// JWT payload ÏµúÏÜå ÌòïÌÉú
type JwtPayload = { sub: string };

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
    constructor(
        private readonly usersService: UsersService,
        configService: ConfigService,
    ) {
        super({
            // ‚úÖ Authorization Ìó§Îçî ‚ùå
            // ‚úÖ access_token Ïø†ÌÇ§ÏóêÏÑú JWT Ï∂îÏ∂ú
            jwtFromRequest: ExtractJwt.fromExtractors([
                (req) => {
                    return req?.cookies?.access_token;
                },
            ]),

            secretOrKey: configService.get<string>('JWT_SECRET')!,
            ignoreExpiration: false,
        });
    }

    async validate(payload: JwtPayload) {
        const user = await this.usersService.findById(payload.sub);

        if (!user) {
            throw new UnauthorizedException();
        }

        return user; // req.user
    }
}
</file>

<file path="src/auth/auth.controller.ts">
import {
    Controller,
    Post,
    Get,
    Body,
    Req,
    Res,
    UseGuards,
} from '@nestjs/common';
import { ApiBearerAuth } from '@nestjs/swagger';
import type { Request, Response } from 'express';

import { AuthService } from '@/auth/auth.service';
import { JwtAuthGuard } from '@/auth/guards/jwt-auth.guard';

import { SignupDto } from '@/auth/dto/signup.dto';
import { LoginDto } from '@/auth/dto/login.dto';
import { KakaoLoginDto } from '@/auth/dto/kakao-login.dto';

@ApiBearerAuth()
@Controller('auth')
export class AuthController {
    constructor(
        private readonly authService: AuthService,
    ) { }

    /* =====================
     * ÌöåÏõêÍ∞ÄÏûÖ
     * ===================== */
    @Post('signup')
    signup(@Body() dto: SignupDto) {
        return this.authService.signup(dto);
    }

    /* =====================
     * LOCAL Î°úÍ∑∏Ïù∏
     * ===================== */
    @Post('login')
    async login(
        @Body() dto: LoginDto,
        @Res({ passthrough: true }) res: Response,
    ) {
        const { accessToken, refreshToken } =
            await this.authService.login(dto);

        this.setAuthCookies(res, accessToken, refreshToken);

        return { ok: true };
    }

    /* =====================
     * KAKAO Î°úÍ∑∏Ïù∏
     * ===================== */
    @Post('kakao')
    async kakaoLogin(
        @Body() dto: KakaoLoginDto,
        @Res({ passthrough: true }) res: Response,
    ) {
        const { accessToken, refreshToken } =
            await this.authService.kakaoLogin(dto.code);

        this.setAuthCookies(res, accessToken, refreshToken);

        return { ok: true };
    }

    /* =====================
     * ÌÜ†ÌÅ∞ Ïû¨Î∞úÍ∏â
     * ===================== */
    @Post('refresh')
    async refresh(
        @Req() req: Request,
        @Res({ passthrough: true }) res: Response,
    ) {
        const refreshToken = req.cookies?.refresh_token;

        const { accessToken, refreshToken: nextRefreshToken } =
            await this.authService.refresh({ refreshToken });

        this.setAuthCookies(res, accessToken, nextRefreshToken);

        return { ok: true };
    }

    /* =====================
     * Î°úÍ∑∏ÏïÑÏõÉ
     * ===================== */
    @Post('logout')
    async logout(
        @Req() req: Request,
        @Res({ passthrough: true }) res: Response,
    ) {
        const refreshToken = req.cookies?.refresh_token;

        await this.authService.logout(refreshToken);

        // Ïø†ÌÇ§ ÏÇ≠Ï†ú
        res.clearCookie('access_token', { path: '/' });
        res.clearCookie('refresh_token', { path: '/auth/refresh' });

        return { ok: true };
    }


    /* =====================
     * ÎÇ¥ Ï†ïÎ≥¥
     * ===================== */
    @Get('me')
    @UseGuards(JwtAuthGuard)
    me(@Req() req: any) {
        return req.user;
    }

    /* =====================
     * Ïø†ÌÇ§ ÏÑ∏ÌåÖ Ìó¨Ìçº
     * ===================== */
    private setAuthCookies(
        res: Response,
        accessToken: string,
        refreshToken: string,
    ) {
        res.cookie('access_token', accessToken, {
            httpOnly: true,
            sameSite: 'lax',
            secure: false, // prodÏóêÏÑúÎäî true
            path: '/',
        });

        res.cookie('refresh_token', refreshToken, {
            httpOnly: true,
            sameSite: 'lax',
            secure: false, // prodÏóêÏÑúÎäî true
            path: '/auth/refresh',
        });
    }
}
</file>

<file path="src/auth/auth.module.ts">
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { HttpModule } from '@nestjs/axios';

import { AuthController } from '@/auth/auth.controller';
import { AuthService } from '@/auth/auth.service';
import { JwtStrategy } from '@/auth/strategies/jwt.strategy';

import { RefreshTokenService } from '@/auth/refresh-token.service';
import { UsersModule } from '@/users/users.module';


@Module({
    imports: [
        HttpModule,
        UsersModule,
        PassportModule,
        ConfigModule, // isGlobal ÏïÑÎãàÎ©¥ ÌïÑÏàò

        JwtModule.registerAsync({
            imports: [ConfigModule],
            inject: [ConfigService],
            useFactory: (config: ConfigService) => ({
                secret: config.get<string>('JWT_SECRET'),
                signOptions: { expiresIn: '1d' },
            }),
        }),

    ],
    controllers: [AuthController],
    providers: [AuthService, JwtStrategy, RefreshTokenService],
})
export class AuthModule { }
</file>

<file path="src/auth/auth.service.ts">
import {
    Injectable,
    UnauthorizedException,
    ConflictException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';
import * as bcrypt from 'bcrypt';

import { UsersService } from '@/users/users.service';
import { RefreshTokenService } from '@/auth/refresh-token.service';
import { AuthProvider, User } from '@prisma/client';

@Injectable()
export class AuthService {
    constructor(
        private readonly usersService: UsersService,
        private readonly jwtService: JwtService,
        private readonly http: HttpService,
        private readonly refreshTokenService: RefreshTokenService,
    ) { }

    /* =====================
     * LOCAL ÌöåÏõêÍ∞ÄÏûÖ
     * ===================== */
    async signup(params: {
        email: string;
        password: string;
        name?: string;
    }): Promise<User> {
        const { email, password, name } = params;

        const exists = await this.usersService.findLocalByEmail(email);
        if (exists) {
            throw new ConflictException('Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Ïù¥Î©îÏùº');
        }

        const passwordHash = await bcrypt.hash(password, 10);

        return this.usersService.createLocalUser({
            email,
            passwordHash,
            name,
        });
    }

    /* =====================
     * LOCAL Î°úÍ∑∏Ïù∏
     * ===================== */
    async login(params: {
        email: string;
        password: string;
    }): Promise<{ accessToken: string; refreshToken: string }> {
        const { email, password } = params;

        const user = await this.usersService.findLocalByEmail(email);
        if (!user || !user.passwordHash) {
            throw new UnauthorizedException('Ïù¥Î©îÏùº ÎòêÎäî ÎπÑÎ∞ÄÎ≤àÌò∏ Ïò§Î•ò');
        }

        const isValid = await bcrypt.compare(password, user.passwordHash);
        if (!isValid) {
            throw new UnauthorizedException('Ïù¥Î©îÏùº ÎòêÎäî ÎπÑÎ∞ÄÎ≤àÌò∏ Ïò§Î•ò');
        }

        return this.issueTokens(user);
    }

    /* =====================
     * KAKAO Î°úÍ∑∏Ïù∏
     * ===================== */
    async kakaoLogin(
        code: string,
    ): Promise<{ accessToken: string; refreshToken: string }> {
        // 1. Ïπ¥Ïπ¥Ïò§ ÌÜ†ÌÅ∞ ÏöîÏ≤≠
        const tokenRes = await firstValueFrom(
            this.http.post(
                'https://kauth.kakao.com/oauth/token',
                new URLSearchParams({
                    grant_type: 'authorization_code',
                    client_id: process.env.KAKAO_REST_API_KEY!,
                    redirect_uri: process.env.KAKAO_REDIRECT_URI!,
                    code,
                    client_secret: process.env.KAKAO_CLIENT_SECRET!,
                }),
                {
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                },
            ),
        );

        const kakaoAccessToken = tokenRes.data.access_token;
        if (!kakaoAccessToken) {
            throw new UnauthorizedException('Ïπ¥Ïπ¥Ïò§ ÌÜ†ÌÅ∞ Î∞úÍ∏â Ïã§Ìå®');
        }

        // 2. Ïπ¥Ïπ¥Ïò§ Ïú†Ï†Ä Ï†ïÎ≥¥ Ï°∞Ìöå
        const userRes = await firstValueFrom(
            this.http.get('https://kapi.kakao.com/v2/user/me', {
                headers: {
                    Authorization: `Bearer ${kakaoAccessToken}`,
                },
            }),
        );

        const kakaoId = String(userRes.data.id);
        const email = userRes.data.kakao_account?.email;
        const name = userRes.data.kakao_account?.profile?.nickname;

        // 3. Ïú†Ï†Ä Ï°∞Ìöå / ÏÉùÏÑ±
        let user = await this.usersService.findByProvider(
            AuthProvider.KAKAO,
            kakaoId,
        );

        if (!user) {
            user = await this.usersService.createOAuthUser({
                provider: AuthProvider.KAKAO,
                providerId: kakaoId,
                email,
                name,
            });
        }

        return this.issueTokens(user);
    }

    /* =====================
     * refresh token Ïû¨Î∞úÍ∏â
     * ===================== */
    async refresh(params: {
        refreshToken: string;
    }): Promise<{ accessToken: string; refreshToken: string }> {
        const { refreshToken } = params;
        if (!refreshToken) {
            throw new UnauthorizedException('refresh token ÌïÑÏöî');
        }

        // 1) refresh Ïú†Ìö®ÏÑ±/DB Ï°¥Ïû¨ ÌôïÏù∏
        const record = await this.refreshTokenService.validate(refreshToken);

        // 2) rotation: Í∏∞Ï°¥ refresh ÌèêÍ∏∞
        await this.refreshTokenService.revoke(refreshToken);

        // 3) ÏÉà ÌÜ†ÌÅ∞Îì§ Î∞úÍ∏â
        const accessToken = this.issueAccessToken(record.userId);
        const nextRefreshToken = await this.refreshTokenService.issue(record.userId);

        return { accessToken, refreshToken: nextRefreshToken };
    }

    /* =====================
     * Î°úÍ∑∏ÏïÑÏõÉ
     * ===================== */
    async logout(refreshToken?: string): Promise<void> {
        if (!refreshToken) {
            return;
        }

        await this.refreshTokenService.revoke(refreshToken);
    }


    /* =====================
     * access + refresh Î∞úÍ∏â
     * ===================== */
    private async issueTokens(
        user: User,
    ): Promise<{ accessToken: string; refreshToken: string }> {
        const accessToken = this.issueAccessToken(user.id);
        const refreshToken = await this.refreshTokenService.issue(user.id);

        return { accessToken, refreshToken };
    }

    /* =====================
     * access token
     * ===================== */
    private issueAccessToken(userId: string): string {
        return this.jwtService.sign(
            { sub: userId },
            { expiresIn: '15m' },
        );
    }





}
</file>

<file path="src/auth/refresh-token.service.ts">
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PrismaService } from '@/common/prisma/prisma.service';
import { randomBytes, createHash } from 'crypto';
import dayjs from 'dayjs';

@Injectable()
export class RefreshTokenService {
    constructor(
        private readonly prisma: PrismaService,
    ) { }

    /* =====================
     * refresh token ÏÉùÏÑ±
     * ===================== */
    generateToken(): string {
        return randomBytes(64).toString('hex');
    }

    /* =====================
     * refresh token Ìï¥Ïãú
     * ===================== */
    hashToken(token: string): string {
        return createHash('sha256').update(token).digest('hex');
    }

    /* =====================
     * refresh token Î∞úÍ∏â + Ï†ÄÏû•
     * ===================== */
    async issue(userId: string): Promise<string> {
        const token = this.generateToken();
        const tokenHash = this.hashToken(token);

        await this.prisma.refreshToken.create({
            data: {
                userId,
                tokenHash,
                expiresAt: dayjs().add(14, 'day').toDate(),
            },
        });

        return token; // ÏõêÎ¨∏ÏùÄ Ïó¨Í∏∞ÏÑúÎßå
    }

    /* =====================
     * refresh token Í≤ÄÏ¶ù
     * ===================== */
    async validate(token: string) {
        const tokenHash = this.hashToken(token);

        const record = await this.prisma.refreshToken.findUnique({
            where: { tokenHash },
        });

        if (!record) {
            throw new UnauthorizedException('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ refresh token');
        }

        if (record.revokedAt) {
            throw new UnauthorizedException('ÌèêÍ∏∞Îêú refresh token');
        }

        if (dayjs(record.expiresAt).isBefore(dayjs())) {
            throw new UnauthorizedException('ÎßåÎ£åÎêú refresh token');
        }

        return record;
    }

    /* =====================
     * refresh token ÌèêÍ∏∞
     * ===================== */
    async revoke(token: string): Promise<void> {
        const tokenHash = this.hashToken(token);

        await this.prisma.refreshToken.updateMany({
            where: {
                tokenHash,
                revokedAt: null,
            },
            data: {
                revokedAt: new Date(),
            },
        });
    }
}
</file>

<file path="src/common/prisma/prisma.module.ts">
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global() // Ï†ÑÏó≠ÏúºÎ°ú Ïç®Î®πÍ∏∞
@Module({
    providers: [PrismaService],
    exports: [PrismaService],
})
export class PrismaModule { }
</file>

<file path="src/common/prisma/prisma.service.ts">
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
    extends PrismaClient
    implements OnModuleInit, OnModuleDestroy {
    // Ïï± ÏãúÏûë Ïãú DB Ïó∞Í≤∞
    async onModuleInit() {
        console.log('üü° Prisma init start');
        await this.$connect();
        console.log('üü¢ Prisma connected');
    }

    // Ïï± Ï¢ÖÎ£å Ïãú DB Ïó∞Í≤∞ Ìï¥Ï†ú
    async onModuleDestroy() {
        await this.$disconnect();
    }
}
</file>

<file path="src/forms/dto/draft/create-form-draft.dto.ts">
import {
    IsArray,
    IsBoolean,
    IsEnum,
    IsNotEmpty,
    IsOptional,
    IsString,
    ValidateNested,
} from 'class-validator';
import { Type } from 'class-transformer';

export enum QuestionType {
    SHORT_TEXT = 'SHORT_TEXT',
    LONG_TEXT = 'LONG_TEXT',
    SINGLE_CHOICE = 'SINGLE_CHOICE',
    MULTIPLE_CHOICE = 'MULTIPLE_CHOICE',
}

class CreateQuestionOptionDto {
    @IsString()
    @IsNotEmpty()
    label: string;

    @IsString()
    @IsOptional()
    value?: string;
}

class CreateQuestionDto {
    @IsString()
    @IsNotEmpty()
    title: string;

    @IsEnum(QuestionType)
    type: QuestionType;

    @IsBoolean()
    isRequired: boolean;

    @IsArray()
    @IsOptional()
    @ValidateNested({ each: true })
    @Type(() => CreateQuestionOptionDto)
    options?: CreateQuestionOptionDto[];
}

class CreateFormPayloadDto {
    @IsString()
    @IsNotEmpty()
    title: string;

    @IsString()
    @IsOptional()
    description?: string;
}

export class CreateFormDraftDto {
    @ValidateNested()
    @Type(() => CreateFormPayloadDto)
    form: CreateFormPayloadDto;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CreateQuestionDto)
    questions: CreateQuestionDto[];
}
</file>

<file path="src/forms/dto/draft/create-form-publish.dto.ts">
import {
    IsArray,
    IsBoolean,
    IsEnum,
    IsNotEmpty,
    IsOptional,
    IsString,
    ValidateNested,
} from 'class-validator';
import { Type } from 'class-transformer';

export enum QuestionType {
    SHORT_TEXT = 'SHORT_TEXT',
    LONG_TEXT = 'LONG_TEXT',
    SINGLE_CHOICE = 'SINGLE_CHOICE',
    MULTIPLE_CHOICE = 'MULTIPLE_CHOICE',
}

class CreateQuestionOptionDto {
    @IsString()
    @IsNotEmpty()
    label: string;

    @IsString()
    @IsOptional()
    value?: string;
}

class CreateQuestionDto {
    @IsString()
    @IsNotEmpty()
    title: string;

    @IsEnum(QuestionType)
    type: QuestionType;

    @IsBoolean()
    isRequired: boolean;

    @IsArray()
    @IsOptional()
    @ValidateNested({ each: true })
    @Type(() => CreateQuestionOptionDto)
    options?: CreateQuestionOptionDto[];
}

class CreateFormPayloadDto {
    @IsString()
    @IsNotEmpty()
    title: string;

    @IsString()
    @IsOptional()
    description?: string;
}

export class CreateFormPublishDto {
    @ValidateNested()
    @Type(() => CreateFormPayloadDto)
    form: CreateFormPayloadDto;

    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CreateQuestionDto)
    questions: CreateQuestionDto[];
}
</file>

<file path="src/forms/dto/create-form.dto.ts">
import { IsString, IsOptional, IsNotEmpty } from 'class-validator';

export class CreateFormDto {
    @IsString()
    @IsNotEmpty()
    title: string;

    @IsString()
    @IsOptional()
    description?: string;
}
</file>

<file path="src/forms/dto/update-form.dto.ts">
import { IsString, IsOptional } from 'class-validator';

export class UpdateFormDto {
    @IsString()
    @IsOptional()
    title?: string;

    @IsString()
    @IsOptional()
    description?: string;
}
</file>

<file path="src/forms/forms.controller.ts">
import {
    Controller,
    Post,
    Get,
    Patch,
    Delete,
    Param,
    Body,
    Req,
    UseGuards,
    NotFoundException,
} from '@nestjs/common';
import { ApiBearerAuth } from '@nestjs/swagger';

import { JwtAuthGuard } from '@/auth/guards/jwt-auth.guard';
import { FormsService } from '@/forms/forms.service';

import { CreateFormDto } from '@/forms/dto/create-form.dto';
import { UpdateFormDto } from '@/forms/dto/update-form.dto';
import { CreateFormDraftDto } from '@/forms/dto/draft/create-form-draft.dto';
import { CreateFormPublishDto } from '@/forms/dto/draft/create-form-publish.dto';


@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller('forms')
export class FormsController {
    constructor(private readonly formsService: FormsService) { }

    // ÏÉùÏÑ±
    @Post()
    create(@Req() req: Request & { user: { id: string } },
        @Body() dto: CreateFormDto) {
        return this.formsService.create(req.user.id, dto);
    }

    // Ï°∞Ìöå
    @Get()
    findAll(@Req() req: Request & { user: { id: string } }) {
        return this.formsService.findAll(req.user.id);
    }

    // Îã®Í±¥ Ï°∞Ìöå
    @Get(':id')
    async findOne(@Req() req: Request & { user: { id: string } }, @Param('id') id: string) {
        const form = await this.formsService.findOne(req.user.id, id);
        if (!form) throw new NotFoundException('Form not found');
        return form;
    }

    // ÏàòÏ†ï
    @Patch(':id')
    async update(
        @Req() req: Request & { user: { id: string } },
        @Param('id') id: string,
        @Body() dto: UpdateFormDto,
    ) {
        const result = await this.formsService.update(req.user.id, id, dto);
        if (result.count === 0) throw new NotFoundException('Form not found');
        return { success: true };
    }

    // ÏÇ≠Ï†ú (soft delete)
    @Delete(':id')
    async remove(@Req() req: Request & { user: { id: string } }, @Param('id') id: string) {
        const result = await this.formsService.remove(req.user.id, id);
        if (result.count === 0) throw new NotFoundException('Form not found');
        return { success: true };
    }

    // Draft Ï†ÄÏû•
    @Post('draft')
    createDraft(
        @Req() req: Request & { user: { id: string } },
        @Body() dto: CreateFormDraftDto,
    ) {
        return this.formsService.createDraftWithQuestions(req.user.id, dto);
    }

    // Publish Ï†ÄÏû•
    @Post('publish')
    publish(
        @Req() req: Request & { user: { id: string } },
        @Body() dto: CreateFormPublishDto,
    ) {
        return this.formsService.publishWithQuestions(req.user.id, dto);
    }


}
</file>

<file path="src/forms/forms.module.ts">
import { Module } from '@nestjs/common';
import { FormsController } from '@/forms/forms.controller';
import { FormsService } from '@/forms/forms.service';
import { PrismaModule } from '@/common/prisma/prisma.module';
import { RefreshTokenService } from '@/auth/refresh-token.service';

@Module({
    imports: [PrismaModule],
    controllers: [FormsController],
    providers: [FormsService, RefreshTokenService],
})
export class FormsModule { }
</file>

<file path="src/forms/forms.service.ts">
import { Injectable } from "@nestjs/common";
import { PrismaService } from "@/common/prisma/prisma.service";
import { CreateFormDto } from "@/forms/dto/create-form.dto";
import { UpdateFormDto } from "@/forms/dto/update-form.dto";
import { CreateFormDraftDto } from "@/forms/dto/draft/create-form-draft.dto";
import { CreateFormPublishDto } from "@/forms/dto/draft/create-form-publish.dto";
import { FormStatus } from "@prisma/client";

@Injectable()
export class FormsService {
    constructor(private readonly prisma: PrismaService) { }

    // Ìèº ÏÉùÏÑ±
    create(userId: string, dto: CreateFormDto) {
        return this.prisma.form.create({
            data: {
                title: dto.title,
                description: dto.description,
                owner_id: userId,
            },
        });
    }

    // Ìèº Ï°∞Ìöå
    findAll(userId: string) {
        return this.prisma.form.findMany({
            where: {
                owner_id: userId,
                is_active: true,
            },
            orderBy: {
                created_at: 'desc',
            },
        });
    }

    // Ìèº Îã®Í±¥ Ï°∞Ìöå(ÏßàÎ¨∏, ÏòµÏÖò Ìè¨Ìï®)
    findOne(userId: string, formId: string) {
        // findUnique Ïì∞Î©¥ Í∂åÌïú Ï°∞Í±¥ Î™ª ÎÑ£Ïùå.
        // Ïïà ÎÇòÏò§Î©¥ null Î∞òÌôò ‚Üí Ïª®Ìä∏Î°§Îü¨ÏóêÏÑú Ï≤òÎ¶¨.
        return this.prisma.form.findFirst({
            where: {
                id: formId,
                owner_id: userId,
                is_active: true,
            },
            include: {
                questions: {
                    orderBy: { order_index: 'asc' },
                    include: {
                        options: {
                            orderBy: { order_index: 'asc' },
                        },
                    },
                },
            },
        });

    }

    // Ìèº ÏàòÏ†ï
    update(userId: string, formId: string, dto: UpdateFormDto) {
        return this.prisma.form.updateMany({
            where: {
                id: formId,
                owner_id: userId,
                is_active: true,
            },
            data: {
                ...dto,
            },
        });
    }

    // Ìèº ÏÇ≠Ï†ú
    remove(userId: string, formId: string) {
        // delete ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÍ≥† Î≥µÍµ¨ Ïó¨ÏßÄ ÎÇ®Í∏∞Í∏∞. 
        return this.prisma.form.updateMany({
            where: {
                id: formId,
                owner_id: userId,
                is_active: true,
            },
            data: {
                is_active: false,
            },
        });
    }

    // =========================
    // Draft / Publish
    // =========================
    async createDraftWithQuestions(
        userId: string,
        dto: CreateFormDraftDto,
    ) {
        return this.createFormWithQuestions(
            userId,
            dto,
            FormStatus.DRAFT,
        );
    }

    async publishWithQuestions(
        userId: string,
        dto: CreateFormPublishDto,
    ) {
        return this.createFormWithQuestions(
            userId,
            dto,
            FormStatus.PUBLISHED,
        );
    }

    private async createFormWithQuestions(
        userId: string,
        dto: CreateFormDraftDto | CreateFormPublishDto,
        status: FormStatus,
    ) {
        const { form, questions } = dto;

        return this.prisma.$transaction(async tx => {
            // 1. Form ÏÉùÏÑ±
            const createdForm = await tx.form.create({
                data: {
                    title: form.title,
                    description: form.description,
                    owner_id: userId,
                    status,
                },
            });

            // 2. Question ÏÉùÏÑ±
            for (let i = 0; i < questions.length; i++) {
                const question = questions[i];

                const createdQuestion = await tx.question.create({
                    data: {
                        form_id: createdForm.id,
                        title: question.title,
                        type: question.type,
                        is_required: question.isRequired,
                        order_index: i,
                    },
                });

                // 3. Option ÏÉùÏÑ± (ÏûàÏùÑ ÎïåÎßå)
                if (question.options?.length) {
                    await tx.questionOption.createMany({
                        data: question.options.map((option, idx) => ({
                            question_id: createdQuestion.id,
                            label: option.label,
                            value: option.value,
                            order_index: idx,
                        })),
                    });
                }
            }

            return createdForm;
        });
    }



}
</file>

<file path="src/permissions/permissions.module.ts">

</file>

<file path="src/permissions/permissions.service.ts">

</file>

<file path="src/public-links/public-links.controller.ts">

</file>

<file path="src/public-links/public-links.module.ts">

</file>

<file path="src/question-options/dto/create-question-option.dto.ts">
import { IsArray, IsInt, IsOptional, IsString, Min, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';

class CreateOptionItemDto {
    @IsString()
    label: string;

    @IsOptional()
    @IsString()
    value?: string;

    @IsInt()
    @Min(0)
    orderIndex: number;
}

export class CreateQuestionOptionDto {
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CreateOptionItemDto)
    options: CreateOptionItemDto[];
}
</file>

<file path="src/question-options/dto/delete-question-option.dto.ts">
import { IsArray, IsUUID } from 'class-validator';

export class DeleteQuestionOptionDto {
    @IsArray()
    @IsUUID('4', { each: true })
    optionIds: string[];
}
</file>

<file path="src/question-options/dto/reorder-question-option.dto.ts">
import { IsArray, IsUUID } from 'class-validator';

export class ReorderQuestionOptionDto {
    @IsArray()
    @IsUUID('4', { each: true })
    orderedOptionIds: string[];
}
</file>

<file path="src/question-options/question-options.controller.ts">
import { Body, Controller, Delete, Param, Patch, Post } from '@nestjs/common';
import { QuestionOptionsService } from '@/question-options/question-options.service';
import { CreateQuestionOptionDto } from '@/question-options/dto/create-question-option.dto';
import { ReorderQuestionOptionDto } from '@/question-options/dto/reorder-question-option.dto';
import { DeleteQuestionOptionDto } from '@/question-options/dto/delete-question-option.dto';

@Controller('questions/:questionId/options')
export class QuestionOptionsController {
    constructor(private readonly service: QuestionOptionsService) { }

    @Post()
    create(
        @Param('questionId') questionId: string,
        @Body() dto: CreateQuestionOptionDto,
    ) {
        return this.service.createOptions(questionId, dto.options);
    }

    @Patch('reorder')
    reorder(
        @Param('questionId') questionId: string,
        @Body() dto: ReorderQuestionOptionDto,
    ) {
        return this.service.reorderOptions(questionId, dto.orderedOptionIds);
    }

    @Delete()
    delete(
        @Param('questionId') questionId: string,
        @Body() dto: DeleteQuestionOptionDto,
    ) {
        return this.service.deleteOptions(questionId, dto.optionIds);
    }
}
</file>

<file path="src/question-options/question-options.module.ts">
import { Module } from '@nestjs/common';
import { QuestionOptionsService } from '@/question-options/question-options.service';
import { QuestionOptionsController } from '@/question-options/question-options.controller';
import { PrismaModule } from '@/common/prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  providers: [QuestionOptionsService],
  controllers: [QuestionOptionsController],
})
export class QuestionOptionsModule { }
</file>

<file path="src/question-options/question-options.service.ts">
import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { PrismaService } from '@/common/prisma/prisma.service';


@Injectable()
export class QuestionOptionsService {
    constructor(private readonly prisma: PrismaService) { }

    // ÏòµÏÖò ÏÉùÏÑ±
    async createOptions(
        questionId: string,
        options: {
            label: string;
            value?: string;
            orderIndex: number;
        }[],
    ) {
        if (options.length === 0) return [];

        return this.prisma.$transaction(async (tx) => {
            // 1. ÏßàÎ¨∏ Ï°¥Ïû¨ + ÌÉÄÏûÖ Ï≤¥ÌÅ¨
            const question = await tx.question.findUnique({
                where: { id: questionId },
                select: { id: true, type: true },
            });

            if (!question) {
                throw new NotFoundException('Question not found');
            }

            if (!['SINGLE_CHOICE', 'MULTIPLE_CHOICE'].includes(question.type)) {
                throw new BadRequestException('This question type does not support options');
            }

            // 2. bulk create
            await tx.questionOption.createMany({
                data: options.map((opt) => ({
                    question_id: questionId,
                    label: opt.label,
                    value: opt.value,
                    order_index: opt.orderIndex,
                })),
            });

            // 3. ÏÉùÏÑ±Îêú ÏòµÏÖò Î∞òÌôò
            return tx.questionOption.findMany({
                where: { question_id: questionId },
                orderBy: { order_index: 'asc' },
            });
        });
    }


    // ÏòµÏÖò Ïû¨Ï†ïÎ†¨
    async reorderOptions(
        questionId: string,
        orderedOptionIds: string[],
    ) {
        if (orderedOptionIds.length === 0) return;

        return this.prisma.$transaction(async (tx) => {
            // 1. Ìï¥Îãπ questionÏùò ÏòµÏÖòÏù∏ÏßÄ Í≤ÄÏ¶ù
            const options = await tx.questionOption.findMany({
                where: {
                    id: { in: orderedOptionIds },
                    question_id: questionId,
                },
                select: { id: true },
            });

            if (options.length !== orderedOptionIds.length) {
                throw new Error('Invalid option ids for this question');
            }

            // 2. ÏàúÏÑúÎåÄÎ°ú order_index ÏóÖÎç∞Ïù¥Ìä∏
            const updates = orderedOptionIds.map((id, index) =>
                tx.questionOption.update({
                    where: { id },
                    data: { order_index: index },
                }),
            );

            await Promise.all(updates);

            // 3. ÏµúÏ¢Ö ÏÉÅÌÉú Î∞òÌôò
            return tx.questionOption.findMany({
                where: { question_id: questionId },
                orderBy: { order_index: 'asc' },
            });
        });
    }


    // ÏòµÏÖò ÏÇ≠Ï†ú
    async deleteOptions(
        questionId: string,
        optionIds: string[],
    ) {
        if (optionIds.length === 0) return;

        return this.prisma.$transaction(async (tx) => {
            // 1. Ìï¥Îãπ questionÏùò ÏòµÏÖòÏù∏ÏßÄ Í≤ÄÏ¶ù
            const options = await tx.questionOption.findMany({
                where: {
                    id: { in: optionIds },
                    question_id: questionId,
                },
                select: { id: true },
            });

            if (options.length !== optionIds.length) {
                throw new Error('Invalid option ids for this question');
            }

            // 2. ÏÇ≠Ï†ú
            await tx.questionOption.deleteMany({
                where: {
                    id: { in: optionIds },
                    question_id: questionId,
                },
            });

            // 3. ÎÇ®ÏùÄ ÏòµÏÖò Ï†ïÎ†¨ Ïû¨Ï°∞Ìöå
            return tx.questionOption.findMany({
                where: { question_id: questionId },
                orderBy: { order_index: 'asc' },
            });
        });
    }

}
</file>

<file path="src/questions/dto/create-question.dto.ts">
import { IsEnum, IsOptional, IsBoolean, IsString, IsNotEmpty } from 'class-validator';
import { QuestionType } from '@prisma/client';

export class CreateQuestionDto {
    @IsString()
    @IsNotEmpty()
    title: string;

    @IsEnum(QuestionType)
    type: QuestionType;

    @IsBoolean()
    @IsOptional()
    is_required?: boolean;
}
</file>

<file path="src/questions/dto/reorder-questions.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsUUID } from 'class-validator';

export class ReorderQuestionsDto {
    @ApiProperty({
        type: [String],
        example: [
            "d4c6893f-12a5-4974-9e59-ce0c29e36d43",
            "e734dd9c-a144-409f-a3ff-74daa7dece88",
            "9602fcf0-c74e-4845-92b6-224da3837ee6"
        ],
    })
    @IsArray()
    @IsUUID('all', { each: true })
    questionIds: string[];
}
</file>

<file path="src/questions/dto/update-question.dto.ts">
import { IsOptional, IsString, IsBoolean } from 'class-validator';

export class UpdateQuestionDto {
    @IsString()
    @IsOptional()
    title?: string;

    @IsBoolean()
    @IsOptional()
    is_required?: boolean;
}
</file>

<file path="src/questions/questions.controller.ts">
import {
    Controller,
    Post,
    Get,
    Patch,
    Delete,
    Param,
    Body,
    Req,
    UseGuards,
    UsePipes,
    ValidationPipe,
} from '@nestjs/common';
import { ApiBearerAuth, ApiParam } from '@nestjs/swagger';

import { JwtAuthGuard } from '@/auth/guards/jwt-auth.guard';
import { QuestionsService } from '@/questions/questions.service';

import { CreateQuestionDto } from '@/questions/dto/create-question.dto';
import { UpdateQuestionDto } from '@/questions/dto/update-question.dto';
import { ReorderQuestionsDto } from '@/questions/dto/reorder-questions.dto';


@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller('forms/:formId/questions')
export class QuestionsController {
    constructor(private readonly questionsService: QuestionsService) { }

    // ÏßàÎ¨∏ ÏÉùÏÑ±
    @Post()
    create(
        @Param('formId') formId: string,
        @Req() req: Request & { user: { id: string } },
        @Body() dto: CreateQuestionDto,
    ) {
        return this.questionsService.create(formId, req.user.id, dto);
    }

    // ÏßàÎ¨∏Îì§ Ï°∞Ìöå
    @Get()
    findAll(
        @Param('formId') formId: string,
        @Req() req: Request & { user: { id: string } },
    ) {
        return this.questionsService.findAll(formId, req.user.id);
    }

    // ÏßàÎ¨∏ ÏàúÏÑú Ïû¨Î∞∞Ïπò
    @Patch('reorder')
    @UsePipes(
        new ValidationPipe({
            whitelist: true,
            forbidNonWhitelisted: true,
            transform: true,
        }),
    )
    reorder(
        @Param('formId') formId: string,
        @Req() req: Request & { user: { id: string } },
        @Body() dto: ReorderQuestionsDto,
    ) {
        return this.questionsService.reorder(
            formId,
            req.user.id,
            dto.questionIds,
        );
    }
    /* NestJS ÎùºÏö∞ÌåÖ Ï£ºÏùòÏÇ¨Ìï≠
     *
     * - Ï†ïÏ†Å ÎùºÏö∞Ìä∏(@Patch('reorder'))Îäî
     *   ÎèôÏ†Å ÎùºÏö∞Ìä∏(@Patch(':id'))Î≥¥Îã§ Î∞òÎìúÏãú ÏúÑÏóê ÏÑ†Ïñ∏Ìï¥Ïïº ÌïúÎã§.
     *
     * - ÏÑ†Ïñ∏ ÏàúÏÑúÍ∞Ä Îí§ÏßëÌûàÎ©¥
     *   'reorder'Í∞Ä ':id'Î°ú Îß§Ïπ≠ÎêòÏñ¥
     *   ÏùòÎèÑÌïòÏßÄ ÏïäÏùÄ Ìï∏Îì§Îü¨(update Îì±)Í∞Ä Ïã§ÌñâÎêúÎã§.
     *
     * - Ïù¥ Í≤ΩÏö∞:
     *   - Ïã§Ï†ú Î©îÏÑúÎìúÎäî Ìò∏Ï∂úÎêòÏßÄ ÏïäÏùå
     *   - DTO Î°úÍ∑∏ÎèÑ Ï∞çÌûàÏßÄ ÏïäÏùå
     *   - ValidationPipe ÏóêÎü¨Í∞Ä DTO Î¨∏Ï†úÏ≤òÎüº Î≥¥ÏûÑ
     *
     * - Ìï¥Í≤∞:
     *   1. Ï†ïÏ†Å ÎùºÏö∞Ìä∏Î•º ÏúÑÏóê Î∞∞Ïπò
     *   2. ÎùºÏö∞Ìä∏ Íµ¨Ï°∞Î•º ÌååÎùºÎØ∏ÌÑ∞ÏôÄ Í≤πÏπòÏßÄ ÏïäÍ≤å ÏÑ§Í≥Ñ
     *   3. ÎùºÏö∞Ìä∏ ÏàúÏÑú Î≥ÄÍ≤Ω ÌõÑ ÏÑúÎ≤Ñ Ïû¨ÏãúÏûë Í∂åÏû•
     */


    // ÏßàÎ¨∏ ÏàòÏ†ï
    @Patch(':id')
    @ApiParam({
        name: 'formId',
        required: true,
        description: 'Ìèº ID',
    })
    @ApiParam({
        name: 'id',
        required: true,
        description: 'ÏßàÎ¨∏ ID',
    })
    update(
        @Param('id') id: string,
        @Req() req: Request & { user: { id: string } },
        @Body() dto: UpdateQuestionDto,
    ) {
        return this.questionsService.update(id, req.user.id, dto);
    }

    // ÏßàÎ¨∏ ÏÇ≠Ï†ú
    @Delete(':id')
    @ApiParam({
        name: 'formId',
        required: true,
        description: 'Ìèº ID',
    })
    @ApiParam({
        name: 'id',
        required: true,
        description: 'ÏßàÎ¨∏ ID',
    })
    remove(
        @Param('id') id: string,
        @Req() req: Request & { user: { id: string } },
    ) {
        return this.questionsService.remove(id, req.user.id);
    }


}
</file>

<file path="src/questions/questions.module.ts">
import { Module } from '@nestjs/common';
import { QuestionsController } from '@/questions/questions.controller';
import { QuestionsService } from '@/questions/questions.service';
import { PrismaModule } from '@/common/prisma/prisma.module';

@Module({
    imports: [PrismaModule],
    controllers: [QuestionsController],
    providers: [QuestionsService],
})
export class QuestionsModule { }
</file>

<file path="src/questions/questions.service.ts">
import { Injectable, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '@/common/prisma/prisma.service';
import { QuestionType } from '@prisma/client';

interface CreateQuestionInput {
  title: string;
  type: QuestionType;
  is_required?: boolean;
}

@Injectable()
export class QuestionsService {
  constructor(private readonly prisma: PrismaService) { }

  // ÏßàÎ¨∏Îì§ ÏÉùÏÑ±
  async create(formId: string, userId: string, input: CreateQuestionInput) {
    // 1. Form ÏÜåÏú†Ïûê ÌôïÏù∏
    const form = await this.prisma.form.findFirst({
      where: {
        id: formId,
        owner_id: userId,
        is_active: true,
      },
    });

    if (!form) {
      throw new ForbiddenException('Form not accessible');
    }

    // 2. order_index Í≥ÑÏÇ∞ (ÎßàÏßÄÎßâ + 1)
    const lastQuestion = await this.prisma.question.findFirst({
      where: { form_id: formId },
      orderBy: { order_index: 'desc' },
    });

    const nextOrderIndex = lastQuestion ? lastQuestion.order_index + 1 : 0;

    // 3. Question ÏÉùÏÑ±
    return this.prisma.question.create({
      data: {
        form_id: formId,
        title: input.title,
        type: input.type,
        is_required: input.is_required ?? false,
        order_index: nextOrderIndex,
      },
    });
  }

  // Ï†ÑÏ≤¥ ÏßàÎ¨∏ Ï°∞Ìöå
  async findAll(formId: string, userId: string) {
    // form ÏÜåÏú†Ïûê Í≤ÄÏ¶ù
    const form = await this.prisma.form.findFirst({
      where: {
        id: formId,
        owner_id: userId,
        is_active: true,
      },
    });

    if (!form) {
      throw new ForbiddenException('Form not accessible');
    }

    // ÏßàÎ¨∏ Î™©Î°ù Ï°∞Ìöå
    return this.prisma.question.findMany({
      where: {
        form_id: formId,
      },
      orderBy: {
        order_index: 'asc',
      },
    });
  }

  // ÏßàÎ¨∏ ÏàòÏ†ï
  async update(
    questionId: string,
    userId: string,
    input: { title?: string; is_required?: boolean },
  ) {
    // ÏßàÎ¨∏ + ÏÜåÏú†Ïûê Í≤ÄÏ¶ù
    const question = await this.prisma.question.findFirst({
      where: {
        id: questionId,
        form: {
          owner_id: userId,
          is_active: true,
        },
      },
    });

    if (!question) {
      throw new ForbiddenException('Question not accessible');
    }

    return this.prisma.question.update({
      where: { id: questionId },
      data: {
        title: input.title,
        is_required: input.is_required,
      },
    });
  }

  // ÏßàÎ¨∏ ÏÇ≠Ï†ú(ÏôÑÏ†Ñ)
  async remove(questionId: string, userId: string) {
    // 1. ÏßàÎ¨∏ + ÏÜåÏú†Ïûê Í≤ÄÏ¶ù
    const question = await this.prisma.question.findFirst({
      where: {
        id: questionId,
        form: {
          owner_id: userId,
          is_active: true,
        },
      },
    });

    if (!question) {
      throw new ForbiddenException('Question not accessible');
    }

    const { form_id, order_index } = question;

    // 2. ÏßàÎ¨∏ ÏÇ≠Ï†ú
    await this.prisma.question.delete({
      where: { id: questionId },
    });

    // 3. Îí§Ïóê ÏûàÎäî ÏßàÎ¨∏Îì§ order_index ÎãπÍ∏∞Í∏∞
    await this.prisma.question.updateMany({
      where: {
        form_id,
        order_index: { gt: order_index },
      },
      data: {
        order_index: { decrement: 1 },
      },
    });

    return { success: true };
  }

  // ÏßàÎ¨∏ ÏàúÏÑú Ïû¨Î∞∞Ïπò
  async reorder(
    formId: string,
    userId: string,
    questionIds: string[],
  ) {
    // 1. form ÏÜåÏú†Ïûê Í≤ÄÏ¶ù
    const form = await this.prisma.form.findFirst({
      where: {
        id: formId,
        owner_id: userId,
        is_active: true,
      },
    });

    if (!form) {
      throw new ForbiddenException('Form not accessible');
    }

    // 2. Ìä∏ÎûúÏû≠ÏÖòÏúºÎ°ú ÏàúÏÑú Ïû¨Î∞∞Ïπò
    await this.prisma.$transaction(
      questionIds.map((id, index) =>
        this.prisma.question.update({
          where: { id },
          data: { order_index: index },
        }),
      ),
    );

    return { success: true };
  }




}
</file>

<file path="src/responses/dto/create-response-answer.dto.ts">
import { IsString, IsOptional } from 'class-validator';

export class CreateResponseAnswerDto {
    @IsString()
    questionId: string;

    @IsOptional()
    @IsString()
    valueText?: string;

    @IsOptional()
    @IsString()
    optionId?: string;
}
</file>

<file path="src/responses/dto/create-response.dto.ts">
import { IsString, IsOptional, IsArray } from 'class-validator';
import { CreateResponseAnswerDto } from './create-response-answer.dto';

export class CreateResponseDto {
    @IsString()
    formId: string;

    @IsOptional()
    @IsString()
    publicToken?: string;

    @IsArray()
    answers: CreateResponseAnswerDto[];
}
</file>

<file path="src/responses/responses.controller.ts">
import { Controller, Post, UseGuards, Body, Req } from "@nestjs/common";
import { OptionalJwtAuthGuard } from "@/auth/guards/optional-jwt-auth.guard";
import { ResponseService } from "@/responses/responses.service";
import { CreateResponseDto } from "@/responses/dto/create-response.dto";

@Controller('responses')
export class ResponseController {
    constructor(
        private readonly responseService: ResponseService,
    ) { }

    @Post()
    @UseGuards(OptionalJwtAuthGuard)
    async create(@Body() dto: CreateResponseDto, @Req() req: any) {
        return this.responseService.create(dto, req.user);
    }
}
</file>

<file path="src/responses/responses.module.ts">
import { Module } from "@nestjs/common";
import { ResponseController } from "@/responses/responses.controller";
import { ResponseService } from "@/responses/responses.service";

@Module({
    controllers: [ResponseController],
    providers: [ResponseService],
})
export class ResponsesModule { }
</file>

<file path="src/responses/responses.service.ts">
import { Injectable, BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
import { PrismaService } from '@/common/prisma/prisma.service';
import { CreateResponseDto } from '@/responses/dto/create-response.dto';
import { User } from '@prisma/client';

@Injectable()
export class ResponseService {
    constructor(private readonly prisma: PrismaService) { }

    async create(dto: CreateResponseDto, user?: User) {
        const { formId, publicToken, answers } = dto;

        if (!user && !publicToken) {
            throw new ForbiddenException();
        }

        const form = await this.prisma.form.findFirst({
            where: { id: formId, is_active: true },
            include: {
                questions: {
                    include: { options: true },
                },
            },
        });

        if (!form) throw new NotFoundException();

        // questionId Ï§ëÎ≥µ Ï≤¥ÌÅ¨
        const questionIdSet = new Set(answers.map(a => a.questionId));
        if (questionIdSet.size !== answers.length) {
            throw new BadRequestException('duplicate question');
        }

        // ÌïÑÏàò ÏßàÎ¨∏ Ï≤¥ÌÅ¨ + ÌÉÄÏûÖ Í≤ÄÏ¶ù
        for (const q of form.questions) {
            const answer = answers.find(a => a.questionId === q.id);

            if (q.is_required && !answer) {
                throw new BadRequestException('required question missing');
            }

            if (!answer) continue;

            switch (q.type) {
                case 'SHORT_TEXT':
                case 'LONG_TEXT':
                    if (!answer.valueText || answer.optionId) {
                        throw new BadRequestException('invalid text answer');
                    }
                    break;

                case 'SINGLE_CHOICE':
                case 'MULTIPLE_CHOICE':
                    if (!answer.optionId || answer.valueText) {
                        throw new BadRequestException('invalid choice answer');
                    }
                    if (!q.options.some(o => o.id === answer.optionId)) {
                        throw new BadRequestException('option not belongs to question');
                    }
                    break;
            }
        }

        // Ìä∏ÎûúÏû≠ÏÖò ÏõêÏûêÏÑ± Î≥¥Ïû•
        return this.prisma.$transaction(async tx => {
            const response = await tx.response.create({
                data: {
                    form_id: form.id,
                    responderId: user?.id ?? null,
                    publicToken: publicToken ?? null,
                },
            });

            for (const a of answers) {
                await tx.responseAnswer.create({
                    data: {
                        response_id: response.id,
                        question_id: a.questionId,
                        value_text: a.valueText ?? null,
                        option_id: a.optionId ?? null,
                    },
                });
            }

            return response.id;
        });
    }
}
</file>

<file path="src/users/users.controller.ts">
import { Controller } from '@nestjs/common';

@Controller('users')
export class UsersController { }

// 'users'Îäî URL prefix
</file>

<file path="src/users/users.module.ts">
import { Module } from '@nestjs/common';
import { UsersController } from '@/users/users.controller';
import { UsersService } from '@/users/users.service';

@Module({
    controllers: [UsersController],
    providers: [UsersService],
    exports: [UsersService],
})
export class UsersModule { }
</file>

<file path="src/users/users.service.ts">
import { Injectable, ConflictException } from '@nestjs/common';
import { PrismaService } from '@/common/prisma/prisma.service';
import { AuthProvider, User } from '@prisma/client';

@Injectable()
export class UsersService {
    constructor(
        private readonly prisma: PrismaService,
    ) { }

    // LOCAL Ï†ÑÏö© (Ïù¥Î©îÏùº Î°úÍ∑∏Ïù∏)
    async findLocalByEmail(email: string): Promise<User | null> {
        return this.prisma.user.findFirst({
            where: {
                email,
                provider: AuthProvider.LOCAL,
            },
        });
    }

    // OAuth Ï†ÑÏö© (provider + providerId)
    async findByProvider(
        provider: AuthProvider,
        providerId: string,
    ): Promise<User | null> {
        return this.prisma.user.findUnique({
            where: {
                provider_providerId: {
                    provider,
                    providerId,
                },
            },
        });
    }

    async findById(id: string): Promise<User | null> {
        return this.prisma.user.findUnique({ where: { id } });
    }

    // LOCAL ÌöåÏõêÍ∞ÄÏûÖ
    async createLocalUser(params: {
        email: string;
        passwordHash: string;
        name?: string;
    }): Promise<User> {
        const { email, passwordHash, name } = params;

        return this.prisma.user.create({
            data: {
                email,
                passwordHash,
                name,
                provider: AuthProvider.LOCAL,
            },
        });
    }

    // OAuth Ïú†Ï†Ä ÏÉùÏÑ± (KAKAO / GOOGLE)
    async createOAuthUser(params: {
        provider: AuthProvider;
        providerId: string;
        email?: string;
        name?: string;
    }): Promise<User> {
        const { provider, providerId, email, name } = params;

        // email Ï∂©Îèå Í≤ÄÏÇ¨ (LOCAL Í≥ÑÏ†ï Î≥¥Ìò∏)
        if (email) {
            const exists = await this.prisma.user.findFirst({
                where: {
                    email,
                    provider: AuthProvider.LOCAL,
                },
            });

            if (exists) {
                throw new ConflictException('Ïù¥ÎØ∏ LOCAL Í≥ÑÏ†ïÏù¥ Ï°¥Ïû¨Ìï®');
            }
        }

        return this.prisma.user.create({
            data: {
                provider,
                providerId,
                email,
                name,
            },
        });
    }
}
</file>

<file path="src/app.module.ts">
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from '@/common/prisma/prisma.module';
import { AuthModule } from '@/auth/auth.module';
import { UsersModule } from '@/users/users.module';
import { FormsModule } from '@/forms/forms.module';
import { QuestionsModule } from '@/questions/questions.module';
import { QuestionOptionsModule } from '@/question-options/question-options.module';
import { ResponsesModule } from '@/responses/responses.module';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    PrismaModule,
    UsersModule,
    AuthModule,
    FormsModule,
    QuestionsModule,
    QuestionOptionsModule,
    ResponsesModule,
  ],
})
export class AppModule { }
</file>

<file path="src/main.ts">
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import cookieParser from 'cookie-parser';
import { AppModule } from '@/app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // ‚úÖ cookie parser
  app.use(cookieParser());

  // ‚úÖ Ï†ÑÏó≠ ValidationPipe
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    }),
  );

  const config = new DocumentBuilder()
    .setTitle('CRATE API')
    .setDescription('CRATE Backend API')
    .setVersion('1.0')
    .addBearerAuth() // SwaggerÏö©, Ïã§Ï†ú Ïù∏Ï¶ùÏùÄ Ïø†ÌÇ§
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api-docs', app, document);

  await app.listen(3000);
}

bootstrap();
</file>

<file path="test/app.e2e-spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import request from 'supertest';
import { AppModule } from '@/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});
</file>

<file path="test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
</file>

<file path=".env.dev">

</file>

<file path=".env.prod">

</file>

<file path=".eslintrc.js">
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  rules: {
    '@typescript-eslint/no-explicit-any': 'error',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-unused-vars': ['error'],
  },
};
</file>

<file path=".gitignore">
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# docker volume
postgres_data/


# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

/generated/prisma
</file>

<file path=".prettierrc">
{
  "singleQuote": true,
  "trailingComma": "all",
  "printWidth": 100,
  "semi": true
}
</file>

<file path="docker-compose.yml">
services:
  postgres:
    image: postgres:16
    container_name: crate-postgres
    environment:
      POSTGRES_USER: crate
      POSTGRES_PASSWORD: crate
      POSTGRES_DB: crate
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
</file>

<file path="nest-cli.json">
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
</file>

<file path="package.json">
{
  "name": "crate-backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/axios": "^4.0.1",
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.2",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/swagger": "^11.2.3",
    "@prisma/client": "^6.19.1",
    "bcrypt": "^6.0.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.3",
    "cookie-parser": "^1.4.7",
    "dayjs": "^1.11.19",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "prisma": "^6.19.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "swagger-ui-express": "^5.0.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@types/bcrypt": "^6.0.0",
    "@types/cookie-parser": "^1.4.10",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.10.7",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
</file>

<file path="README.md">
# üì¶ CRATE Backend (Dev README)

> **Í∞úÎ∞ú ÏßÑÌñâÏö© README**
> Ïã§Î¨¥ Í∏∞Ï§Ä Íµ¨Ï°∞/ÌùêÎ¶Ñ Ï†ïÎ¶¨ Î¨∏ÏÑúÏù¥Î©∞, Ìè¨Ìä∏Ìè¥Î¶¨Ïò§Ïö©Ïù¥ ÏïÑÎãò

---

## 1. ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏöî

* ÏÑúÎπÑÏä§Î™Ö: **CRATE**
* ÏÑ±Í≤©: **ÏßÄÏõêÏÑú ¬∑ ÏÑ§Î¨∏ Ìèº + ÌèâÍ∞Ä/ÏÑ†Î∞ú ÌîåÎû´Ìèº**
* Ìè¨ÏßÄÏÖò: Google Forms ÎåÄÏ≤¥ + ÌèâÍ∞Ä/Í∂åÌïú/Î∂ÑÎ∞∞ Ï§ëÏã¨

### ÌïµÏã¨ Ïª®ÏÖâ

* Form ‚Üí Question ‚Üí Option ‚Üí Response ‚Üí Evaluation
* Î™®Îì† Í∂åÌïú Í≤ÄÏ¶ùÏùÄ **ÏÑúÎ≤ÑÏóêÏÑú Í∞ïÏ†ú**
* MVP ‚Üí ÌôïÏû• Ï†ÑÏ†ú Íµ¨Ï°∞

---

## 2. Í∏∞Ïà† Ïä§ÌÉù

* Framework: **NestJS (TypeScript)**
* DB: **PostgreSQL**
* ORM: **Prisma**
* Auth: **JWT + RefreshToken + httpOnly Cookie**
* Infra: Î°úÏª¨ Í∞úÎ∞ú Í∏∞Ï§Ä

---

## 3. ÏïÑÌÇ§ÌÖçÏ≤ò ÏõêÏπô

### 3.1 Î™®Îìà Íµ¨Ï°∞

* ÎèÑÎ©îÏù∏ Í∏∞Ï§Ä Î™®Îìà Î∂ÑÎ¶¨
* Controller / Service / Repository(Prisma) Î∂ÑÎ¶¨

### 3.2 ÏÑ§Í≥Ñ Í∏∞Ï§Ä

* CRUDÎ≥¥Îã§ **Îç∞Ïù¥ÌÑ∞ ÌùêÎ¶Ñ Ïö∞ÏÑ†**
* ControllerÎäî ÏöîÏ≤≠ Î∂ÑÌï¥Îßå Îã¥Îãπ
* ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ ¬∑ Í∂åÌïú Í≤ÄÏ¶ùÏùÄ **Service Î†àÎ≤®**
* ÏàúÏÑú Î≥ÄÍ≤Ω, ÏùºÍ¥Ñ Ï≤òÎ¶¨ ‚Üí **Ìä∏ÎûúÏû≠ÏÖò ÌïÑÏàò**

---

## 4. ÌòÑÏû¨ Íµ¨ÌòÑ ÏÉÅÌÉú (2025-12 Í∏∞Ï§Ä)

### ‚úÖ Auth ÎèÑÎ©îÏù∏ (3Ï∞® ÏôÑÎ£å)

#### Í∏∞Îä•

* LOCAL Î°úÍ∑∏Ïù∏ (email + password)
* KAKAO OAuth Î°úÍ∑∏Ïù∏
* access / refresh ÌÜ†ÌÅ∞ Î∂ÑÎ¶¨
* refresh token DB Ï†ÄÏû• (Ìï¥Ïãú)
* refresh token rotation
* httpOnly Ïø†ÌÇ§ Í∏∞Î∞ò Ïù∏Ï¶ù
* Ïø†ÌÇ§ Í∏∞Î∞ò JwtStrategy

#### ÏóîÎìúÌè¨Ïù∏Ìä∏

* `POST /auth/signup`
* `POST /auth/login`
* `POST /auth/kakao`
* `POST /auth/refresh`
* `POST /auth/logout`
* `GET /auth/me`

#### Ïù∏Ï¶ù ÌùêÎ¶Ñ ÏöîÏïΩ

* Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ Ïãú access/refresh ÌÜ†ÌÅ∞ÏùÑ **httpOnly Ïø†ÌÇ§Î°ú Î∞úÍ∏â**
* access ÎßåÎ£å Ïãú `/auth/refresh` Ìò∏Ï∂ú ‚Üí ÏûêÎèô Ïû¨Î∞úÍ∏â
* Î°úÍ∑∏ÏïÑÏõÉ Ïãú refresh ÌèêÍ∏∞ + Ïø†ÌÇ§ ÏÇ≠Ï†ú

---

### ‚úÖ Users / Forms / Questions / QuestionOption

* Í∏∞Î≥∏ CRUD Íµ¨ÌòÑ ÏôÑÎ£å
* Question ÏàúÏÑú(order_index) Í¥ÄÎ¶¨ Ìè¨Ìï®

---

## 5. ÏïÑÏßÅ ÌïòÏßÄ ÏïäÏùÄ Í≤É (ÏùòÎèÑÏ†Å Î≥¥Î•ò)

* ÌÜµÍ≥Ñ / ÏßëÍ≥Ñ
* ÌèâÍ∞Ä Ï†êÏàò Í≥ÑÏÇ∞
* Ï∫êÏã± / ÏÑ±Îä• ÏµúÏ†ÅÌôî
* Î≥µÏû°Ìïú Í∂åÌïú Í≥ÑÏ∏µ
* ÌîÑÎ°†Ìä∏ Ìé∏ÏùòÏö© API

---

## 6. Îã§Ïùå ÏûëÏóÖ Ïö∞ÏÑ†ÏàúÏúÑ

1. **Response ÎèÑÎ©îÏù∏**

   * ÏùëÎãµ ÏÉùÏÑ± ÌùêÎ¶Ñ
   * Ïô∏Î∂Ä Ï†ëÍ∑º(public link) Í∏∞Ï§Ä Ï†ïÏùò

2. **Public Link**

   * ÌÜ†ÌÅ∞ Í∏∞Î∞ò Ïô∏Î∂Ä Ï†ëÍ∑º

3. **Permission / Evaluation**

   * ÌèâÍ∞ÄÏûê Í∂åÌïú Î™®Îç∏
   * ÌèâÍ∞Ä ÎåÄÏÉÅ Î≤îÏúÑ Ï†úÏñ¥

---

## 7. Í∞úÎ∞ú Í∑úÏπô ÏöîÏïΩ

* Ï∂îÏ∏° Í∏àÏßÄ, Ìï≠ÏÉÅ DB Í∏∞Ï§Ä ÏÑ§Î™Ö
* ÌïÑÏöî ÏóÜÎäî Ïª¨Îüº/ÏóîÎìúÌè¨Ïù∏Ìä∏Îäî Î≥¥Î•ò
* Íµ¨Ï°∞ ‚Üí ÌùêÎ¶Ñ ‚Üí ÏΩîÎìú ÏàúÏÑú Í≥†Ï†ï

---

‚ö†Ô∏è Ïù¥ Î¨∏ÏÑúÎäî **Í∞úÎ∞ú ÏßÑÌñâÏóê Îî∞Îùº Í≥ÑÏÜç Í∞±Ïã†Îê®**
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "resolvePackageJsonExports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}
</file>

</files>
